<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot+mybatis数据源动态切换与加载]]></title>
    <url>%2F2018%2F09%2F13%2Fspringboot-mybatis%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于动态切换数据源，需要一个类继承AbstractRoutingDataSource,继承该抽象类的时候，必须实现一个抽象方法：protected abstract Object determineCurrentLookupKey()，该方法用于指定到底需要使用哪一个数据源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean &#123; private Map&lt;Object, Object&gt; targetDataSources; private Object defaultTargetDataSource; private boolean lenientFallback = true; private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup(); private Map&lt;Object, DataSource&gt; resolvedDataSources; private DataSource resolvedDefaultDataSource; public AbstractRoutingDataSource() &#123; &#125; public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123; this.targetDataSources = targetDataSources; &#125; public void setDefaultTargetDataSource(Object defaultTargetDataSource) &#123; this.defaultTargetDataSource = defaultTargetDataSource; &#125; public void setLenientFallback(boolean lenientFallback) &#123; this.lenientFallback = lenientFallback; &#125; public void setDataSourceLookup(DataSourceLookup dataSourceLookup) &#123; this.dataSourceLookup = (DataSourceLookup)(dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup()); &#125; public void afterPropertiesSet() &#123; if (this.targetDataSources == null) &#123; throw new IllegalArgumentException(&quot;Property &apos;targetDataSources&apos; is required&quot;); &#125; else &#123; this.resolvedDataSources = new HashMap(this.targetDataSources.size()); Iterator var1 = this.targetDataSources.entrySet().iterator(); while(var1.hasNext()) &#123; Entry&lt;Object, Object&gt; entry = (Entry)var1.next(); Object lookupKey = this.resolveSpecifiedLookupKey(entry.getKey()); DataSource dataSource = this.resolveSpecifiedDataSource(entry.getValue()); this.resolvedDataSources.put(lookupKey, dataSource); &#125; if (this.defaultTargetDataSource != null) &#123; this.resolvedDefaultDataSource = this.resolveSpecifiedDataSource(this.defaultTargetDataSource); &#125; &#125; &#125; protected Object resolveSpecifiedLookupKey(Object lookupKey) &#123; return lookupKey; &#125; protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException &#123; if (dataSource instanceof DataSource) &#123; return (DataSource)dataSource; &#125; else if (dataSource instanceof String) &#123; return this.dataSourceLookup.getDataSource((String)dataSource); &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal data source value - only [javax.sql.DataSource] and String supported: &quot; + dataSource); &#125; &#125; public Connection getConnection() throws SQLException &#123; return this.determineTargetDataSource().getConnection(); &#125; public Connection getConnection(String username, String password) throws SQLException &#123; return this.determineTargetDataSource().getConnection(username, password); &#125; public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; return iface.isInstance(this) ? this : this.determineTargetDataSource().unwrap(iface); &#125; public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; return iface.isInstance(this) || this.determineTargetDataSource().isWrapperFor(iface); &#125; protected DataSource determineTargetDataSource() &#123; Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;); Object lookupKey = this.determineCurrentLookupKey(); DataSource dataSource = (DataSource)this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123; dataSource = this.resolvedDefaultDataSource; &#125; if (dataSource == null) &#123; throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;); &#125; else &#123; return dataSource; &#125; &#125; protected abstract Object determineCurrentLookupKey();&#125; &emsp;&emsp;自定义动态数据源类1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.example.savesearchservice.util.DataSourceUtil;import com.example.savesearchservice.util.DynamicDatasourceHolder;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import javax.sql.DataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; private static final Log logger = LogFactory.getLog(DynamicDataSource.class); private static Map&lt;Object, Object&gt; datasourceMap = new ConcurrentHashMap&lt;&gt;(); @Override protected Object determineCurrentLookupKey() &#123; logger.info(&quot;current dataSourceId:&quot; + DynamicDatasourceHolder.get()); return DynamicDatasourceHolder.get(); &#125; public DataSource createDatasource(String id, String url, String username, String password, String driverClassName) &#123; DataSource dataSource = DataSourceBuilder.create() .url(url) .username(username) .password(password) .driverClassName(driverClassName) .build(); if (dataSource != null) &#123; DataSourceUtil.put(id, id); datasourceMap.put(id, dataSource); //调用父类方法赋值Map&lt;Object, DataSource&gt; resolvedDataSources super.setTargetDataSources(datasourceMap); super.afterPropertiesSet(); return dataSource; &#125; return null; &#125;&#125; &emsp;&emsp;通过ThreadLocal维护一个全局唯一的map来实现数据源的动态切换12345678910111213141516public class DynamicDatasourceHolder &#123; private static final ThreadLocal&lt;String&gt; DATASOURCE_HOLDER = new ThreadLocal&lt;&gt;(); public static void add(String datasource) &#123; DATASOURCE_HOLDER.set(datasource); &#125; public static String get() &#123; return DATASOURCE_HOLDER.get(); &#125; public static void clear() &#123; DATASOURCE_HOLDER.remove(); &#125;&#125; &emsp;&emsp;通过AOP切面实现动态切换数据源，这里假设projectId与dataSourceId有对应关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import com.example.savesearchservice.annotation.DataSource;import com.example.savesearchservice.datasource.DynamicDataSource;import com.example.savesearchservice.util.DataSourceUtil;import com.example.savesearchservice.util.DynamicDatasourceHolder;import org.apache.commons.lang.StringUtils;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Component@Aspect@Order(-1)public class DynamicDataSourceAOP implements ApplicationContextAware &#123; private static final Log logger = LogFactory.getLog(DynamicDataSourceAOP.class); private ApplicationContext applicationContext; @Pointcut(&quot;execution(* com.example.controller*(..))&quot;) public void pointCut() &#123; &#125; /** * 执行方法前更换数据源 * * @param joinPoint 切点 */ @Before(&quot;@annotation(dataSource)&quot;) public void doBefore(JoinPoint joinPoint, DataSource dataSource) &#123; logger.info(&quot;Enter DataSourceAOP&quot;); String projectId = DataSourceUtil.DEFAULT; Object[] args = joinPoint.getArgs(); if (args.length &gt;= 1) &#123; projectId = String.valueOf(args[0]); &#125; projectId = StringUtils.defaultIfBlank(projectId, DataSourceUtil.DEFAULT); if (!DataSourceUtil.contains(projectId)) &#123; DynamicDataSource dynamicDataSource = applicationContext.getBean(DynamicDataSource.class); //这里可以根据需要从数据库或者其他地方获取数据源连接信息 dynamicDataSource.createDatasource(projectId, &quot;jdbc:mysql://localhost:3306/dynamic_datasource?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&quot;, &quot;XXX&quot;, &quot;XXX&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;); DynamicDatasourceHolder.add(DataSourceUtil.getDataSourceId(projectId)); logger.info(String.format(&quot;change dataSource for %s,dataSourceId: %s&quot;, projectId, DataSourceUtil.getDataSourceId(projectId))); return; &#125; DynamicDatasourceHolder.add(DataSourceUtil.getDataSourceId(projectId)); &#125; /** * 执行方法后清除数据源设置 * * @param joinPoint 切点 */ @After(&quot;@annotation(dataSource)&quot;) public void doAfter(JoinPoint joinPoint, DataSource dataSource) &#123; DynamicDatasourceHolder.clear(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; &emsp;&emsp;新建DataSourceUtil类保存projectId与dataSourceId的对应关系123456789101112131415161718192021222324import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class DataSourceUtil &#123; public static final String DEFAULT = &quot;default&quot;; private static final Map&lt;String, String&gt; dataSourceMap = new ConcurrentHashMap&lt;&gt;(); private DataSourceUtil() &#123; &#125; public static void put(String projectId, String dataSource) &#123; dataSourceMap.put(projectId, dataSource); &#125; public static boolean contains(String projectId) &#123; return dataSourceMap.get(projectId) != null; &#125; public static String getDataSourceId(String projectId) &#123; return dataSourceMap.get(projectId); &#125;&#125; &emsp;&emsp;springboot启动时的配置类配置默认datasource1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import com.example.savesearchservice.datasource.DynamicDataSource;import com.example.savesearchservice.util.DataSourceUtil;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.mybatis.spring.mapper.MapperScannerConfigurer;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.core.io.ClassPathResource;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;import lombok.NonNull;@Configuration@MapperScan(&quot;com.example.savesearchservice.dao&quot;)public class DataSourceConfiguration implements EnvironmentAware &#123; private static Log logger = LogFactory.getLog(DataSourceConfiguration.class); private Environment environment; @Bean DataSource dataSource() &#123; logger.info(&quot;environment:&quot; + environment); DynamicDataSource dynamicDataSource = new DynamicDataSource(); DataSource dataSource = dynamicDataSource.createDatasource(DataSourceUtil.DEFAULT, environment.getProperty(&quot;datasource.url&quot;), environment.getProperty(&quot;datasource.username&quot;), environment.getProperty(&quot;datasource.password&quot;), environment.getProperty(&quot;datasource.driver-class-name&quot;)); dynamicDataSource.setDefaultTargetDataSource(dataSource); return dynamicDataSource; &#125; @Bean SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setConfigLocation(new ClassPathResource(&quot;mybatis/mybatis-conf.xml&quot;)); return sqlSessionFactoryBean.getObject(); &#125; @Bean MapperScannerConfigurer mapperScannerConfigurer() &#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setAnnotationClass(com.example.savesearchservice.annotation.DataSource.class); mapperScannerConfigurer.setBasePackage(&quot;com.example.savesearchservice.dao&quot;); mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;); return mapperScannerConfigurer; &#125; @Bean DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125; @Override public void setEnvironment(@NonNull Environment environment) &#123; this.environment = environment; &#125;&#125; &emsp;&emsp;可以看到，已经实现了数据源的动态切换]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
